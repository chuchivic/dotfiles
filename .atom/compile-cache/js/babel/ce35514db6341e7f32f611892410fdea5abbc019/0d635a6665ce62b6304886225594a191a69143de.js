
"use strict";
var _ = require("lodash");
var balancedMatch = require("balanced-match");

/**
 * Replace all of the characters that are arguments to a certain
 * CSS function with some innocuous character.
 *
 * This is useful if you need to use a RegExp to find a string
 * but want to ignore matches in certain functions (e.g. `url()`,
 * which might contain all kinds of false positives).
 *
 * For example:
 * blurFunctionArguments("abc url(abc) abc", "url") === "abc url(```) abc"
 *
 * @param {string} source
 * @param {string} functionName
 * @param {[string]} blurChar="`"
 * @return {string} - The result string, with the function arguments "blurred"
 */
module.exports = function (source, /*: string*/functionName /*: string*/) /*: string*/{
  var blurChar /*: string*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "`";

  var nameWithParen = functionName.toLowerCase() + "(";
  var lowerCaseSource = source.toLowerCase();
  if (!_.includes(lowerCaseSource, nameWithParen)) {
    return source;
  }

  var functionNameLength /*: number*/ = functionName.length;

  var result = source;
  var searchStartIndex = 0;
  while (lowerCaseSource.indexOf(nameWithParen, searchStartIndex) !== -1) {
    var openingParenIndex = lowerCaseSource.indexOf(nameWithParen, searchStartIndex) + functionNameLength;
    var closingParenIndex = balancedMatch("(", ")", lowerCaseSource.slice(openingParenIndex)).end + openingParenIndex;
    var argumentsLength = closingParenIndex - openingParenIndex - 1;
    result = result.slice(0, openingParenIndex + 1) + _.repeat(blurChar, argumentsLength) + result.slice(closingParenIndex);
    searchStartIndex = closingParenIndex;
  }
  return result;
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL2plc3VzLy5hdG9tL3BhY2thZ2VzL2xpbnRlci1zdHlsZWxpbnQvbm9kZV9tb2R1bGVzL3N0eWxlbGludC9saWIvdXRpbHMvYmx1ckZ1bmN0aW9uQXJndW1lbnRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxZQUFZLENBQUE7QUFDWixJQUFNLENBQUMsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUE7QUFDM0IsSUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLGdCQUFnQixDQUFDLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCL0MsTUFBTSxDQUFDLE9BQU8sR0FBRyxVQUFVLE1BQU0sY0FBYyxZQUFZLDJCQUEwQjtBQUNuRixNQUFNLFFBQVEsZ0JBQWUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLFNBQVMsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFBOztBQUVwRyxNQUFNLGFBQWEsR0FBTSxZQUFZLENBQUMsV0FBVyxFQUFFLE1BQUcsQ0FBQTtBQUN0RCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUE7QUFDNUMsTUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxFQUFFLGFBQWEsQ0FBQyxFQUFFO0FBQy9DLFdBQU8sTUFBTSxDQUFBO0dBQ2Q7O0FBRUQsTUFBTSxrQkFBa0IsZ0JBQWUsWUFBWSxDQUFDLE1BQU0sQ0FBQTs7QUFFMUQsTUFBSSxNQUFNLEdBQUcsTUFBTSxDQUFBO0FBQ25CLE1BQUksZ0JBQWdCLEdBQUcsQ0FBQyxDQUFBO0FBQ3hCLFNBQU8sZUFBZSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtBQUN0RSxRQUFNLGlCQUFpQixHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLGdCQUFnQixDQUFDLEdBQUcsa0JBQWtCLENBQUE7QUFDdkcsUUFBTSxpQkFBaUIsR0FBRyxhQUFhLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxlQUFlLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsaUJBQWlCLENBQUE7QUFDbkgsUUFBTSxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsQ0FBQyxDQUFBO0FBQ2pFLFVBQU0sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxlQUFlLENBQUMsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLENBQUE7QUFDdkgsb0JBQWdCLEdBQUcsaUJBQWlCLENBQUE7R0FDckM7QUFDRCxTQUFPLE1BQU0sQ0FBQTtDQUNkLENBQUEiLCJmaWxlIjoiL2hvbWUvamVzdXMvLmF0b20vcGFja2FnZXMvbGludGVyLXN0eWxlbGludC9ub2RlX21vZHVsZXMvc3R5bGVsaW50L2xpYi91dGlscy9ibHVyRnVuY3Rpb25Bcmd1bWVudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXCJ1c2Ugc3RyaWN0XCJcbmNvbnN0IF8gPSByZXF1aXJlKFwibG9kYXNoXCIpXG5jb25zdCBiYWxhbmNlZE1hdGNoID0gcmVxdWlyZShcImJhbGFuY2VkLW1hdGNoXCIpXG5cbi8qKlxuICogUmVwbGFjZSBhbGwgb2YgdGhlIGNoYXJhY3RlcnMgdGhhdCBhcmUgYXJndW1lbnRzIHRvIGEgY2VydGFpblxuICogQ1NTIGZ1bmN0aW9uIHdpdGggc29tZSBpbm5vY3VvdXMgY2hhcmFjdGVyLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSBuZWVkIHRvIHVzZSBhIFJlZ0V4cCB0byBmaW5kIGEgc3RyaW5nXG4gKiBidXQgd2FudCB0byBpZ25vcmUgbWF0Y2hlcyBpbiBjZXJ0YWluIGZ1bmN0aW9ucyAoZS5nLiBgdXJsKClgLFxuICogd2hpY2ggbWlnaHQgY29udGFpbiBhbGwga2luZHMgb2YgZmFsc2UgcG9zaXRpdmVzKS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqIGJsdXJGdW5jdGlvbkFyZ3VtZW50cyhcImFiYyB1cmwoYWJjKSBhYmNcIiwgXCJ1cmxcIikgPT09IFwiYWJjIHVybChgYGApIGFiY1wiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmN0aW9uTmFtZVxuICogQHBhcmFtIHtbc3RyaW5nXX0gYmx1ckNoYXI9XCJgXCJcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgcmVzdWx0IHN0cmluZywgd2l0aCB0aGUgZnVuY3Rpb24gYXJndW1lbnRzIFwiYmx1cnJlZFwiXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZS8qOiBzdHJpbmcqLywgZnVuY3Rpb25OYW1lLyo6IHN0cmluZyovKS8qOiBzdHJpbmcqLyB7XG4gIGNvbnN0IGJsdXJDaGFyLyo6IHN0cmluZyovID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImBcIlxuXG4gIGNvbnN0IG5hbWVXaXRoUGFyZW4gPSBgJHtmdW5jdGlvbk5hbWUudG9Mb3dlckNhc2UoKX0oYFxuICBjb25zdCBsb3dlckNhc2VTb3VyY2UgPSBzb3VyY2UudG9Mb3dlckNhc2UoKVxuICBpZiAoIV8uaW5jbHVkZXMobG93ZXJDYXNlU291cmNlLCBuYW1lV2l0aFBhcmVuKSkge1xuICAgIHJldHVybiBzb3VyY2VcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uTmFtZUxlbmd0aC8qOiBudW1iZXIqLyA9IGZ1bmN0aW9uTmFtZS5sZW5ndGhcblxuICBsZXQgcmVzdWx0ID0gc291cmNlXG4gIGxldCBzZWFyY2hTdGFydEluZGV4ID0gMFxuICB3aGlsZSAobG93ZXJDYXNlU291cmNlLmluZGV4T2YobmFtZVdpdGhQYXJlbiwgc2VhcmNoU3RhcnRJbmRleCkgIT09IC0xKSB7XG4gICAgY29uc3Qgb3BlbmluZ1BhcmVuSW5kZXggPSBsb3dlckNhc2VTb3VyY2UuaW5kZXhPZihuYW1lV2l0aFBhcmVuLCBzZWFyY2hTdGFydEluZGV4KSArIGZ1bmN0aW9uTmFtZUxlbmd0aFxuICAgIGNvbnN0IGNsb3NpbmdQYXJlbkluZGV4ID0gYmFsYW5jZWRNYXRjaChcIihcIiwgXCIpXCIsIGxvd2VyQ2FzZVNvdXJjZS5zbGljZShvcGVuaW5nUGFyZW5JbmRleCkpLmVuZCArIG9wZW5pbmdQYXJlbkluZGV4XG4gICAgY29uc3QgYXJndW1lbnRzTGVuZ3RoID0gY2xvc2luZ1BhcmVuSW5kZXggLSBvcGVuaW5nUGFyZW5JbmRleCAtIDFcbiAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgb3BlbmluZ1BhcmVuSW5kZXggKyAxKSArIF8ucmVwZWF0KGJsdXJDaGFyLCBhcmd1bWVudHNMZW5ndGgpICsgcmVzdWx0LnNsaWNlKGNsb3NpbmdQYXJlbkluZGV4KVxuICAgIHNlYXJjaFN0YXJ0SW5kZXggPSBjbG9zaW5nUGFyZW5JbmRleFxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiJdfQ==